# Reference: Commandâ€‘Line Interface

The `lectic` command is the primary way to interact with Lectic. It can read
from a file or from standard input, and it offers flags to control how the
result is printed or saved.

## Usage

```bash
lectic [FLAGS] [OPTIONS] [SUBCOMMAND] [ARGS...]
```

## Subcommands

- `lectic lsp`
  Start the LSP server. Transport: stdio.

- `lectic parse`
  Parse a lectic file into a JSON representation of the parsed file
  structure. Useful for programmatic analysis and modification.

  Flags:
  - `--yaml`: Emit YAML instead of JSON.
  - `--reverse`: Ingest JSON (or YAML) output and reconstruct the original
    lectic file.

- `lectic models`
  List available models for providers with detected API keys. Only
  providers with API keys in the environment are queried.

- `lectic script`
  Run an ES module file using Lectic's internal Bun JS runtime. Works as
  a hashbang interpreter, useful for writing subcommands (see below), 
  [hooks](../automation/02_hooks.qmd), and [exec tools](../tools/02_exec.qmd).
  For example:

  ```bash
  #!/bin/env -S lectic script
  console.log("Hello from a lectic script!")
  ```

## Custom Subcommands

Lectic supports git-style custom subcommands. If you invoke `lectic <command>`,
Lectic will look for an executable named `lectic-<command>` in the following
locations (in order):

1. The Lectic configuration directory (e.g., `~/.config/lectic/` on Linux).
2. The Lectic data directory (e.g., `~/.local/share/lectic/` on Linux).
3. Your system `PATH`.

When a custom subcommand is found, it is executed with the remaining arguments.
The subprocess inherits standard input, output, and error streams, and receives
standard Lectic environment variables (like `LECTIC_CONFIG` and `LECTIC_DATA`).

For example, if you create a script named `lectic-hello` in your path:

```bash
#!/bin/bash
echo "Hello from a custom subcommand!"
```

You can run it via:

```bash
lectic hello
```

This mechanism allows you to extend Lectic with your own tools and workflows.

## Bash completion

The repository includes a bash completion script at:

- `extra/tab_complete/lectic_completion.bash`

Source it from your `~/.bashrc`:

```bash
source /path/to/lectic_completion.bash
```

### Custom completion functions for custom subcommands

You can attach a completion function to a custom subcommand by creating a
plugin file. Plugins are sourced when the completion script is loaded.

Supported locations:

- `${XDG_CONFIG_HOME:-$HOME/.config}/lectic/completions/*.bash`
- `${XDG_DATA_HOME:-$HOME/.local/share}/lectic/completions/*.bash`
- Next to the subcommand executable as: `lectic-<cmd>.completion.bash`

A plugin should define a completion function and register it:

```bash
_lectic_complete_foo() {
  local cur
  cur="${COMP_WORDS[COMP_CWORD]}"
  COMPREPLY=( $(compgen -W "--help --verbose" -- "${cur}") )
}

lectic_register_completion foo _lectic_complete_foo
```

The repository includes an example completion plugin for the `worktree`
subcommand at `extra/sandbox/lectic-worktree.completion.bash`.
## Flags and options

- `-v`, `--version`
  Prints the version string.

- `-f`, `--file <PATH>`
  Path to the conversation file (`.lec`) to process. If omitted, Lectic
  reads from standard input.

- `-i`, `--inplace <PATH>`
  Read from the given file and update it in place. Mutually exclusive with
  `--file`.

- `-s`, `--short`
  Only emit the newly generated assistant message, not the full updated
  conversation.

- `-S`, `--Short`
  Like `--short`, but emits only the raw message text (without the
  `:::Speaker` wrapper).

- `-l`, `--log <PATH>`
  Write detailed debug logs to the given file.

- `-q`, `--quiet`
  Suppress printing the assistant's response to stdout.

- `-h`, `--help`
  Show help for all flags and options.

## Constraints

- --inplace cannot be combined with --file.
- --quiet cannot be combined with --short or --Short.

## Common examples

- Generate the next message in a file and update it in place:
  ```bash
  lectic -i conversation.lec
  ```

- Read from stdin and write the full result to stdout:
  ```bash
  cat conversation.lec | lectic
  ```

- Stream just the new assistant message:
  ```bash
  lectic -s -f conversation.lec
  ```

- Add a message from the command line and update the file:
  ```bash
  echo "This is a new message." | lectic -i conversation.lec
  ```

- List available models for detected providers:
  ```bash
  lectic models
  ```

- Start the LSP server (stdio transport):
  ```bash
  lectic lsp
  ```

- Parse a file to JSON:
  ```bash
  lectic parse -f conversation.lec
  ```

- Round-trip a file through parsing and reconstruction:
  ```bash
  lectic parse -f conversation.lec | lectic parse --reverse
  ```
