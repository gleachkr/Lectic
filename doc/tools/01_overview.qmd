# Tools Overview

Tools let your LLM do things. Instead of stopping at text, it can run a
command, query a database, call another agent, or reach out to a service.

## Quick Reference

| Tool | Purpose | Minimal Config |
|------|---------|----------------|
| [`exec`](./02_exec.qmd) | Run commands and scripts | `exec: date` |
| [`sqlite`](./03_sqlite.qmd) | Query SQLite databases | `sqlite: ./data.db` |
| [`mcp`](./04_mcp.qmd) | Connect to MCP servers | `mcp_command: npx ...` |
| [`agent`](./05_agent.qmd) | Call another interlocutor | `agent: OtherName` |
| [`think`](./06_other_tools.qmd#the-think-tool) | Private reasoning scratchpad | `think_about: the problem` |
| [`serve`](./06_other_tools.qmd#the-serve-tool) | Serve HTML to browser | `serve_on_port: 8080` |
| [`native`](./06_other_tools.qmd#native-tools) | Provider built-ins (search, code) | `native: search` |

## How Tool Calls Work

In Lectic, you configure tools for each interlocutor in the YAML frontmatter.
A tool call follows a four-step process:

1. **User Prompt**: You ask something that requires a tool.
2. **LLM Tool Call**: The LLM outputs a block indicating which tool to use.
3. **Lectic Executes**: Lectic runs the tool and captures output.
4. **LLM Response**: The tool output goes back to the LLM, which answers.

## Tool Call Syntax

Lectic uses XML blocks for tool calls:

```xml
<tool-call with="tool_name">
<arguments>
  <!-- one element per parameter -->
</arguments>
<results>
  <!-- filled by Lectic after execution -->
</results>
</tool-call>
```

You'll see these in assistant blocks. Lectic writes the block when the model
requests a tool, then appends results after running it.

### Example

Configuration:

```yaml
---
interlocutor:
  name: Assistant
  prompt: You are a helpful assistant.
  tools:
    - exec: date
      name: get_date
---

What's the date today?
```

Result:

````markdown
:::Assistant

<tool-call with="get_date">
<arguments><argv>[ ]</argv></arguments>
<results>
<result type="text">
┆<stdout>Fri Mar 15 14:35:18 PDT 2024</stdout>
</result>
</results>
</tool-call>

Today is March 15th, 2024.

:::
````

## Parallel Execution

When an LLM uses multiple tools in one turn, Lectic runs them concurrently.
This speeds up tasks that gather information from several sources.

## Tool Kits

Reuse tool sets across interlocutors by defining named kits.

Kits can also include an optional `description`, which is shown in editor
hovers and autocomplete.

```yaml
kits:
  - name: typescript_tools
    description: TypeScript checks (tsc + eslint)
    tools:
      - exec: tsc --noEmit
        name: typecheck
      - exec: eslint
        name: lint

interlocutor:
  name: Assistant
  prompt: You help with TypeScript.
  tools:
    - kit: typescript_tools
    - exec: cat
      name: read_file
```

## Hooks

The `tool_use_pre` hook fires after parameters are collected but before
execution. If the hook exits non-zero, the call is blocked:

```yaml
interlocutor:
  tools:
    - exec: rm
      name: delete
      hooks:
        - on: tool_use_pre
          do: ~/.config/lectic/confirm.sh
```

See [Hooks](../automation/02_hooks.qmd) for details.

## Tool Guides

Each tool type has its own detailed guide:

- **[Exec](./02_exec.qmd)**: Shell commands and scripts. The most versatile
  tool — anything you can run from the command line, your LLM can run too.

- **[SQLite](./03_sqlite.qmd)**: Direct database queries. Schema is
  auto-introspected and provided to the LLM.

- **[MCP](./04_mcp.qmd)**: Model Context Protocol servers. Connect to a
  growing ecosystem of pre-built tools and services.

- **[Agent](./05_agent.qmd)**: Multi-LLM workflows. One interlocutor can
  delegate to another, enabling specialized agents.

- **[Other Tools](./06_other_tools.qmd)**: The `think` tool for reasoning,
  `serve` for rendering HTML, and `native` for provider built-ins like
  web search.

::: {.callout-note}
Native tools (`native: search`, `native: code`) do not support hooks.
:::
